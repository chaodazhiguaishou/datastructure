#include <iostream>
#include <stdio.h>
using namespace std;

//二叉排序树和平衡二叉树被称为二路查找树
//而B树是一种平衡的多路查找树，多用于文件系统、数据库的实现。需要满足以下特征
// 1.若根结点不是叶子结点，那么根节点至少有两颗子树；
// 2.树中的每个结点最多有m棵子树（即最多含有m-1个关键字，设MAX=m-1）
// 3.每个非根节点至少有m/2棵子树（即至少包含（m/2）-1个关键字，设MIN=(m/2) - 1 ）
// 4.每个结点结构为 n p0 key1 p1 key2 ... keyn pn 其中n代表关键字个数 (m/2)-1 <= n <= m-1
//   且pi指向的子树上的所有关键字值要大于keyi小于keyi+！
// 5.所有的叶子结点都位于同一层。

//b树的查找：因为内部结点的关键字序列是有序的，所以在根节点的key[i]中查找
// 1.若k=key[i]，查找到
// 2.若k<key[i]，沿着指针p0子树继续查找
// 3.若key[i]<k<key[i+1]，沿着指针pi的子树继续查找
// 4.若key[n]<k，沿着指针pn的子树继续查找

// b树的插入：将关键字k插入到m阶b树
// 1.首先查找到关键字k到插入结点p（一定是某个叶子结点）
// 2.判断结点p是否还有空位置，即关键字个数n是否满足n<MAX=m-1
//     (a)若n<MAX成立，说明有空位置，直接把关键字k有序插入结点p中
//     (b)若n=MAX，说明没有空位置，需要把结点p分裂成两个。方法是把结点p加上k之后从n/2位置对半分成两个结点，
//        同时将中间位置n/2的关键字连同分裂出来的结点插入双亲结点。
//        如果此时双亲结点的关键字个数也超过了则继续分裂传递到根节点，如果根节点也分裂则该树整体增高一层

// b树的删除：在m阶b树中删除关键字k
// 1.首先查找到关键字k所在到结点k
// 2.实施关键字k的删除操作
// 不一定可以直接删除，因为可以导致不再满足m阶b树。有两种情况，一是结点p是叶子结点，二是结点p不是叶子结点
// 情况二：情况二需要被转换为情况一，转换过程为当结点p不是叶子结点的时候，
// 假设结点p中的关键字key[i]=k，以p[i]所指右子树中的最小关键字mink来代替被删关键字key[i]（值代替），再删除mink
// 或者以p[i+1]所指左子树中的最大关键字maxk来代替。由于m阶b树的性质，此时mink/maxk一定是叶子结点
//
// 情况一：即在m阶b树的某个叶子结点q中删除关键字k'=mink/maxk
// (a)若n>MIN=(m/2)-1，说明删除后仍满足b树定义，直接删除
// (b)若n=MIN，则要看结点q的左（或右）兄弟结点中关键字个数大于MIN的，首先将双亲结点的kt下移到q覆盖k'，
//    然后将左（或右）兄弟结点中最大（或最小）的关键字k''上移覆盖掉kt
// (c)若n=MIN，且无法从兄弟结点中借关键字。那么则将结点q和左（或右）以及双亲结点中的分割关键字合并为一个结点。





class Solution
{
public:

};

int main() {
    // insert code here...
};