#include <iostream>
#include <stdio.h>
using namespace std;

//1.排序思路
// 采用堆方法选出最大元素：堆排序算法
// 堆的定义:一个序列R[0..n-1]，关键字分别为k0、k1、...、kn-1。该序列满足如下性质（简称为堆性质）：
// 1. ki≤k2i+1 且 ki≤k2i+2   或 2. ki≥k2i+1 且 ki≥k2i+2	（0≤i≤[n/2]-1）
// 满足第1种情况的堆称为小根堆，满足第2种情况的堆称为大根堆。下面讨论的堆是大根堆。

// a.下面将序列a0 a1 … an-1看成是一颗完全二叉树
//    a0         层序编号方式   i
//  a1 a2                 2i+1 2i+2
// 大根堆：对应的完全二叉树中，任意一个结点的关键字都大于或等于它的孩子结点的关键字。最小关键字的元素一定是某个叶子结点！
// b.如何判断一颗完全二叉树是否为大根堆
// 所有分支结点满足定义（分支结点大于它的左右孩子结点）,那么就是大根堆。


//2.排序算法
// 堆排序的关键是构造堆，这里采用筛选算法建堆。
// 所谓“筛选”指的是，对一棵左/右子树均为堆的完全二叉树，“调整”根结点使整个二叉树也成为一个堆。

// 第一步：筛选
// 自顶向下筛选：从根结点R[low]开始向下依次查找较大的孩子结点，构成一个序列（2，9，4），
// 其中除了2外其他元素的子序列恰好是递减的。
// 采用类似直接插入排序的思路使其成为一个递减序列（因为大根堆中从根到每个叶子结点的路径均构成一个递减序列）。

void siftDown(vector<int>& R,int low,int high)
//R[low..high]的自顶向下筛选
//简单来说就是暂存根结点后，不断往下两两对比，一旦反序则大的上移，直到出现递减，把根结点移下去使得满足递减序列
{  int i=low;
   int j=2*i+1;			//R[j]是R[i]的左孩子
   int tmp=R[i];			//tmp临时保存根结点
   while (j<=high)			//只对R[low..high]的元素进行筛选
   {  if (j<high && R[j]<R[j+1])
         j++;				//若右孩子较大,把j指向右孩子
      if (tmp<R[j]) 			//根结点比孩子结点小
      {  R[i]=R[j];			//将R[j]调整到双亲位置上
         i=j; j=2*i+1;		//修改i和j值,以便继续向下筛选
      }
      else break;			//若根结点比孩子结点大，则筛选结束
   }
   R[i]=tmp;				//原根结点放入最终位置
}

void siftUp(vector<int>& R,int j)  //自底向上筛选:从叶子结点j向上筛选
{  int i=(j-1)/2; 		      //i指向R[j]的双亲
   while (true)
   {  if (R[j]>R[i])		      //若孩子较大
         swap(R[i],R[j]);	      //交换
      if (i==0) break;	      //到达根结点时结束
      j=i; i=(j-1)/2;		      //继续向上调整
   }
}

// 第二步：将完全二叉树用筛选方法变为初始堆
// 第三步：找到最大元素归位
void HeapSort(vector<int>& R,int n)	//堆排序
{  for (int i=n/2-1;i>=0;i--)	//从最后一个分支结点开始循环建立初始堆
      siftDown(R,i,n-1);		//对R[i..n-1]进行筛选
   for (int i=n-1;i>0;i--)	//进行n-1趟排序,每一趟后无序区元素个数减1
   {  swap(R[0],R[i]);	//将无序区中尾元素与R[0]交换，扩大有序区
      siftDown(R,0,i-1);		//对无序区R[0..i-1]继续筛选
   }
}


int main() {
    // insert code here...
};

//3.算法分析
// 堆排序的时间复杂度为O(nlog2n)。
// 空间复杂度为O(1)，不稳定。

